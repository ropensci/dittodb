% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/recording.R
\name{capture_requests}
\alias{capture_requests}
\alias{start_capturing}
\alias{stop_capturing}
\title{Capture and record database transactions and save them as mocks}
\usage{
start_capturing(path, redact_columns = NULL)

stop_capturing()
}
\arguments{
\item{path}{the path to record mocks (default if missing: the first path in
\code{.mockPaths()}.}

\item{redact_columns}{a character vector of columns to redact. Any column
that matches an entry will be redacted with a standard value for the column
type (e.g. characters will be replaced with "[redacted]")}
}
\value{
NULL (invisibily)
}
\description{
When creating database fixtures, it can sometimes be helpful to see record
the responses from the database for use in crafting tests.
}
\details{
You can start
capturing with \code{start_capturing()} and end it with \code{stop_capturing}. All
queries run against a database will be executed like normal, but their
responses will be saved to the mock path given, so that if you use the same
queries later inside of a \code{\link{with_mock_db}} block, the database functions will
return as if they had been run against the database.

\emph{note} You should always call \code{\link[DBI:dbConnect]{DBI::dbConnect}} inside of the capturing
block. When you connect to the database, dbtest sets up the mocks for the
specific database you're connecting to when you call \code{\link[DBI:dbConnect]{DBI::dbConnect}}.
}
\examples{
\dontrun{
start_capturing()
con <- dbConnect(RSQLite::SQLite(), "memory")

df_1 <- dbGetQuery(con, "SELECT * FROM rpostgresql.airlines LIMIT 1")
res <- dbSendQuery(con, "SELECT * FROM rpostgresql.airlines LIMIT 2")
df_2 <- dbFetch(res)

dbDisconnect(con)
stop_capturing()

start_capturing(redact_columns = "carrier")
con <- dbConnect(RSQLite::SQLite(), "memory")

df_1 <- dbGetQuery(con, "SELECT * FROM rpostgresql.airlines LIMIT 3")

dbDisconnect(con)
stop_capturing()
}
}
\keyword{internal}
