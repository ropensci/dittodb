% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/recording.R
\name{capture_requests}
\alias{capture_requests}
\alias{start_db_capturing}
\alias{start_capturing}
\alias{stop_db_capturing}
\alias{stop_capturing}
\title{Capture and record database transactions and save them as mocks}
\usage{
start_db_capturing(path, redact_columns = NULL)

start_capturing(path, redact_columns = NULL)

stop_db_capturing()

stop_capturing()
}
\arguments{
\item{path}{the path to record mocks (default if missing: the first path in
\code{db_mock_paths()}.}

\item{redact_columns}{a character vector of columns to redact. Any column
that matches an entry will be redacted with a standard value for the column
type (e.g. characters will be replaced with "[redacted]")}
}
\value{
NULL (invisibily)
}
\description{
When creating database fixtures, it can sometimes be helpful to see record
the responses from the database for use in crafting tests.
}
\details{
You can start capturing with \code{start_db_capturing()} and end it with
\code{stop_db_capturing}. All queries run against a database will be executed like
normal, but their responses will be saved to the mock path given, so that if
you use the same queries later inside of a \code{\link{with_mock_db}} block, the
database functions will return as if they had been run against the database.

You can redact certain columns using the \code{redact_columns} argument. This will
replace the values in the column with a generic redacted version. This works
by always passing the data being saved through \code{\link[=redact_columns]{redact_columns()}}.

\emph{note} You should always call \code{\link[DBI:dbConnect]{DBI::dbConnect}} inside of the capturing
block. When you connect to the database, dittodb sets up the mocks for the
specific database you're connecting to when you call \code{\link[DBI:dbConnect]{DBI::dbConnect}}.

\code{start_capturing()} and \code{stop_capturing()} do the exact same thing as
\code{start_db_capturing()} and \code{stop_db_capturing()}. They are both deprecated so
as not to clash with other packages when loaded.
}
\examples{
\dontrun{
start_db_capturing()
con <- dbConnect(RSQLite::SQLite(), "memory")

df_1 <- dbGetQuery(con, "SELECT * FROM rpostgresql.airlines LIMIT 1")
res <- dbSendQuery(con, "SELECT * FROM rpostgresql.airlines LIMIT 2")
df_2 <- dbFetch(res)

dbDisconnect(con)
stop_db_capturing()

start_db_capturing(redact_columns = "carrier")
con <- dbConnect(RSQLite::SQLite(), "memory")

df_1 <- dbGetQuery(con, "SELECT * FROM rpostgresql.airlines LIMIT 3")

dbDisconnect(con)
stop_db_capturing()
}
}
\keyword{internal}
